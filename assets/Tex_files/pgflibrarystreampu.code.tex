\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{environ}
% ACM style
\usepackage{newtxmath}
\usepackage{libertine}
\usepackage{inconsolata}
% IEEEtrans style
% \usepackage{mathptmx}

\usepackage{tikz}
\usetikzlibrary{positioning,
                fit,
                patterns,
                calc,
                backgrounds}

\usepackage{color}

\definecolor{Paired-2}{RGB}{166,206,227}
\definecolor{Paired-1}{RGB}{31,120,180}
\definecolor{Paired-4}{RGB}{178,223,138}
\definecolor{Paired-3}{RGB}{51,160,44}
\definecolor{Paired-6}{RGB}{251,154,153}
\definecolor{Paired-5}{RGB}{227,26,28}
\definecolor{Paired-8}{RGB}{253,191,111}
\definecolor{Paired-7}{RGB}{255,127,0}
\definecolor{Paired-10}{RGB}{202,178,214}
\definecolor{Paired-9}{RGB}{106,61,154}
\definecolor{Paired-12}{RGB}{255,255,153}
\definecolor{Paired-11}{RGB}{177,89,40}
\definecolor{Accent-1}{RGB}{127,201,127}
\definecolor{Accent-2}{RGB}{190,174,212}
\definecolor{Accent-3}{RGB}{253,192,134}
\definecolor{Accent-4}{RGB}{255,255,153}
\definecolor{Accent-5}{RGB}{56,108,176}
\definecolor{Accent-6}{RGB}{240,2,127}
\definecolor{Accent-7}{RGB}{191,91,23}
\definecolor{Accent-8}{RGB}{102,102,102}
\definecolor{Spectral-1}{RGB}{158,1,66}
\definecolor{Spectral-2}{RGB}{213,62,79}
\definecolor{Spectral-3}{RGB}{244,109,67}
\definecolor{Spectral-4}{RGB}{253,174,97}
\definecolor{Spectral-5}{RGB}{254,224,139}
\definecolor{Spectral-6}{RGB}{255,255,191}
\definecolor{Spectral-7}{RGB}{230,245,152}
\definecolor{Spectral-8}{RGB}{171,221,164}
\definecolor{Spectral-9}{RGB}{102,194,165}
\definecolor{Spectral-10}{RGB}{50,136,189}
\definecolor{Spectral-11}{RGB}{94,79,162}
\definecolor{Set1-1}{RGB}{228,26,28}
\definecolor{Set1-2}{RGB}{55,126,184}
\definecolor{Set1-3}{RGB}{77,175,74}
\definecolor{Set1-4}{RGB}{152,78,163}
\definecolor{Set1-5}{RGB}{255,127,0}
\definecolor{Set1-6}{RGB}{255,255,51}
\definecolor{Set1-7}{RGB}{166,86,40}
\definecolor{Set1-8}{RGB}{247,129,191}
\definecolor{Set1-9}{RGB}{153,153,153}
\definecolor{Set2-1}{RGB}{102,194,165}
\definecolor{Set2-2}{RGB}{252,141,98}
\definecolor{Set2-3}{RGB}{141,160,203}
\definecolor{Set2-4}{RGB}{231,138,195}
\definecolor{Set2-5}{RGB}{166,216,84}
\definecolor{Set2-6}{RGB}{255,217,47}
\definecolor{Set2-7}{RGB}{229,196,148}
\definecolor{Set2-8}{RGB}{179,179,179}
\definecolor{Dark2-1}{RGB}{27,158,119}
\definecolor{Dark2-2}{RGB}{217,95,2}
\definecolor{Dark2-3}{RGB}{117,112,179}
\definecolor{Dark2-4}{RGB}{231,41,138}
\definecolor{Dark2-5}{RGB}{102,166,30}
\definecolor{Dark2-6}{RGB}{230,171,2}
\definecolor{Dark2-7}{RGB}{166,118,29}
\definecolor{Dark2-8}{RGB}{102,102,102}
\definecolor{Reds-1}{RGB}{255,245,240}
\definecolor{Reds-2}{RGB}{254,224,210}
\definecolor{Reds-3}{RGB}{252,187,161}
\definecolor{Reds-4}{RGB}{252,146,114}
\definecolor{Reds-5}{RGB}{251,106,74}
\definecolor{Reds-6}{RGB}{239,59,44}
\definecolor{Reds-7}{RGB}{203,24,29}
\definecolor{Reds-8}{RGB}{165,15,21}
\definecolor{Reds-9}{RGB}{103,0,13}
\definecolor{Greens-1}{RGB}{247,252,245}
\definecolor{Greens-2}{RGB}{229,245,224}
\definecolor{Greens-3}{RGB}{199,233,192}
\definecolor{Greens-4}{RGB}{161,217,155}
\definecolor{Greens-5}{RGB}{116,196,118}
\definecolor{Greens-6}{RGB}{65,171,93}
\definecolor{Greens-7}{RGB}{35,139,69}
\definecolor{Greens-8}{RGB}{0,109,44}
\definecolor{Greens-9}{RGB}{0,68,27}
\definecolor{Blues-1}{RGB}{247,251,255}
\definecolor{Blues-2}{RGB}{222,235,247}
\definecolor{Blues-3}{RGB}{198,219,239}
\definecolor{Blues-4}{RGB}{158,202,225}
\definecolor{Blues-5}{RGB}{107,174,214}
\definecolor{Blues-6}{RGB}{66,146,198}
\definecolor{Blues-7}{RGB}{33,113,181}
\definecolor{Blues-8}{RGB}{8,81,156}
\definecolor{Blues-9}{RGB}{8,48,107}

\newcommand{\tskminsize}{1.0cm}
\newcommand{\scksize}{0.3cm}
\newcommand{\sckspace}{0.5cm}
\newcommand{\sckshdwsize}{0.25cm}
\newcommand{\thrshdwsize}{0.20cm}

\tikzset{ task/.style    = {draw=Paired-1, rounded corners=0pt, text=Paired-1, minimum height=\tskminsize, minimum width=\tskminsize, inner sep=0.3cm, fill=white} }
\tikzset{ stask/.style   = {draw=Paired-1, rounded corners=0pt, text=Paired-1, minimum height=\tskminsize, minimum width=\tskminsize, inner sep=0.3cm, fill=Paired-1!20} }
\tikzset{ seq/.style     = {draw=Paired-11,rounded corners=2pt, densely dashed} }
\tikzset{ subseq/.style  = {draw=Paired-9, rounded corners=2pt} }
\tikzset{ pip/.style     = {draw=Dark2-8,  dotted, thick, rounded corners=2pt} }
\tikzset{ sin/.style     = {draw=Paired-7, circle, minimum width=\scksize, text=Paired-7!80!black, preaction={fill=white}, pattern=north east lines, pattern color=Paired-7} }
\tikzset{ sout/.style    = {draw=Paired-5, circle, minimum width=\scksize, text=Paired-5!80!black, preaction={fill=white}, pattern=crosshatch dots, pattern color=Paired-5} }
\tikzset{ sfwd/.style    = {draw=Dark2-7,  circle, minimum width=\scksize, text=Dark2-7!80!black,  preaction={fill=white}, pattern=grid, pattern color=Dark2-7} }
\tikzset{ taskcln/.style = {draw=Paired-1!30!white} }
\tikzset{ sincln/.style  = {draw=Paired-7!30!white, preaction={fill=white}, pattern=north east lines, pattern color=Paired-7!30!white} }
\tikzset{ soutcln/.style = {draw=Paired-5!30!white, preaction={fill=white}, pattern=crosshatch dots, pattern color=Paired-5!30!white} }
\tikzset{ sfwdcln/.style = {draw=Dark2-7!30!white,  preaction={fill=white}, pattern=grid, pattern color=Dark2-7!30!white} }
\tikzset{ sinlbl/.style  = {text=Paired-7!80!black, font=\footnotesize} }
\tikzset{ soutlbl/.style = {text=Paired-5!80!black, font=\footnotesize} }
\tikzset{ sfwdlbl/.style = {text=Dark2-7!80!black,  font=\footnotesize} }
\tikzset{ sckshdw/.style = {draw=none, circle,    fill=white, opacity=0.75, minimum  width=\sckshdwsize, inner sep=0pt} }
\tikzset{ thrshdw/.style = {draw=none, rectangle, fill=white, opacity=0.75, minimum height=\thrshdwsize, inner sep=0pt} }
\tikzset{ module/.style  = {draw=Paired-3,  dashed, rounded corners=2pt} }
\tikzset{ bind/.style    = {->,>=latex} }
\tikzset{ bindfwd/.style = {->,>=latex,draw=Dark2-7, densely dashdotted} }
\tikzset{ inv/.style     = {draw=none, fill=none, opacity=0} }

% #1 node options (optional parameter)
% #2 id {ti}
% #3 position {x,y} (can be empty)
% #4 label {label_of_the_task}
% #5 number of input sockets (can be 0)
% #6 number of output sockets (can be 0)
% #7 number of forward sockets (can be 0)
% #8 a list of attributes (can be {"rev", "seq", "sckn"} and can also be empty)
\newcommand{\task}[8][]{
  % parse arguments
  \def\tskid{#2}
  \def\tsklabl{#4}
  \pgfmathsetmacro{\nscki}{#5}
  \pgfmathsetmacro{\nscko}{#6}
  \pgfmathsetmacro{\nsckf}{#7}

  % parse arguments
  \def\tsksiside{west}
  \def\tsksoside{east}
  \def\tskisrev{no}
  \def\tskstyle{task}
  \def\tskisseq{no}
  \def\scknum{no}
  \ifthenelse{\equal{#8}{}} {
  }{
    \pgfmathsetmacro{\nattr}{dim(#8)}
    \pgfmathsetmacro{\nattrmone}{int(\nattr - 1)}
    \foreach \i in {0,...,\nattrmone}{
      \ifthenelse{\nattrmone=0}{
        \pgfmathsetmacro{\curattr}{#8}
      }{
        \pgfmathsetmacro{\curattr}{{#8}[\i]}
      }
      \ifthenelse{\equal{\curattr}{rev}} {
        \xdef\tsksiside{east}
        \xdef\tsksoside{west}
        \xdef\tskisrev{yes}
      }{
        \ifthenelse{\equal{\curattr}{seq}} {
          \xdef\tskstyle{stask}
          \xdef\tskisseq{yes}
        }{
          \ifthenelse{\equal{\curattr}{sckn}} {
            \xdef\scknum{yes}
          }{}
        }
      }
    }
  }

  % compute minimum height
  \pgfmathtruncatemacro{\sckitotdst}{(\nscki + \nsckf - 1) * (\sckspace - \scksize) + (\nscki + \nsckf) * \scksize + 0.15cm}
  \pgfmathtruncatemacro{\sckototdst}{(\nscko + \nsckf - 1) * (\sckspace - \scksize) + (\nscko + \nsckf) * \scksize + 0.15cm}

  \ifnum \numexpr\sckitotdst > \sckototdst
    \pgfmathtruncatemacro{\tskminheight}{\sckitotdst}
  \else
    \pgfmathtruncatemacro{\tskminheight}{\sckototdst}
  \fi

  \pgfmathtruncatemacro{\tskminsizebis}{\tskminsize}
  \ifnum \numexpr\tskminheight > \tskminsizebis
    \pgfmathtruncatemacro{\tskrealminheight}{\tskminheight}
  \else
    \pgfmathtruncatemacro{\tskrealminheight}{\tskminsizebis}
  \fi

  % draw task
  \def\tskpos{#3}
  \ifthenelse{\equal{\tskpos}{}} {
    \node[\tskstyle, align=center, minimum height=\tskrealminheight,#1] (\tskid) {\tsklabl};
  }{
    \pgfmathsetmacro{\tskposx}{{#3}[0]}
    \pgfmathsetmacro{\tskposy}{{#3}[1]}
    \node[\tskstyle, align=center, minimum height=\tskrealminheight,#1] (\tskid) at (\tskposx,\tskposy) {\tsklabl};
  }

  % draw input (+ fwd) socket
  \pgfmathtruncatemacro{\sckitotsize}{(\nscki + \nsckf - 1) * \sckspace}
  \pgfmathtruncatemacro{\sckiinishft}{(\sckitotsize / 2)}
  \pgfmathtruncatemacro{\nsckif}{\nscki + \nsckf}
  \ifnum \numexpr\nsckif > 0
    \pgfmathtruncatemacro{\nsckifmone}{\nscki + \nsckf - 1}
    \foreach \i in {0,...,\nsckifmone} {
      \pgfmathtruncatemacro{\sckiyshift}{((\nsckifmone - \i) * \sckspace) - \sckiinishft}
      \pgfmathtruncatemacro{\sckiid}{\i + 1}
      \ifnum \numexpr \i  < \nscki
        \node[sin, at=(\tskid.\tsksiside), yshift=\sckiyshift] (\tskid_si\sckiid) {};
        \ifthenelse{\equal{\scknum}{yes}} {
          \node[sckshdw, at=(\tskid.\tsksiside), yshift=\sckiyshift] (\tskid_si\sckiid_shdw) {};
          \node[sinlbl,  at=(\tskid_si\sckiid.center)] (\tskid_si\sckiid_lbl) {\i};
        }{}
      \else
        \node[sfwd, at=(\tskid.\tsksiside), yshift=\sckiyshift] (\tskid_si\sckiid) {};
        \node[inv, at=(\tskid_si\sckiid.center)] (\tskid_si\sckiid_fwd) {};
        \ifthenelse{\equal{\scknum}{yes}} {
          \node[sckshdw, at=(\tskid.\tsksiside), yshift=\sckiyshift] (\tskid_si\sckiid_shdw) {};
          \node[sfwdlbl, at=(\tskid_si\sckiid.center)] (\tskid_si\sckiid_lbl) {\i};
        }{}
      \fi
    }
  \fi

  % draw output (+ fwd) socket
  \pgfmathtruncatemacro{\sckototsize}{(\nscko + \nsckf - 1) * \sckspace}
  \pgfmathtruncatemacro{\sckoinishft}{(\sckototsize / 2)}
  \pgfmathtruncatemacro{\nsckof}{\nscko + \nsckf}
  \ifnum \numexpr\nsckof > 0
    \pgfmathtruncatemacro{\nsckofmone}{\nscko + \nsckf - 1}
    \foreach \i in {0,...,\nsckofmone} {
      \pgfmathtruncatemacro{\sckoyshift}{((\nsckofmone - \i) * \sckspace) - \sckoinishft}
      \pgfmathtruncatemacro{\sckoid}{\i + 1}
      \ifnum \numexpr \i  < \nscko
        \node[sout, at=(\tskid.\tsksoside), yshift=\sckoyshift] (\tskid_so\sckoid) {};
        \ifthenelse{\equal{\scknum}{yes}} {
          \node[sckshdw, at=(\tskid.\tsksoside), yshift=\sckoyshift] (\tskid_so\sckoid_shdw) {};
          \node[soutlbl, at=(\tskid_so\sckoid.center)] (\tskid_so\sckoid_lbl) {\i};
        }{}
      \else
        \node[sfwd, at=(\tskid.\tsksoside), yshift=\sckoyshift] (\tskid_so\sckoid) {};
        \node[inv, at=(\tskid_so\sckoid.center)] (\tskid_so\sckoid_fwd) {};
        \ifthenelse{\equal{\scknum}{yes}} {
          \node[sckshdw, at=(\tskid.\tsksoside), yshift=\sckoyshift] (\tskid_so\sckoid_shdw) {};
          \node[sfwdlbl, at=(\tskid_so\sckoid.center)] (\tskid_so\sckoid_lbl) {\i};
        }{}
      \fi
    }
  \fi

  % bind fwd sockets
  \ifnum \numexpr\nsckf > 0
    \pgfmathtruncatemacro{\nsckfmone}{\nsckf - 1}
    \foreach \i in {0,...,\nsckfmone} {
      \pgfmathtruncatemacro{\cursif}{\nscki + \i + 1}
      \pgfmathtruncatemacro{\cursof}{\nscko + \i + 1}
      \ifthenelse{\equal{\tskisrev}{yes}} {
        \draw let
          \p1=($(\tskid.west)-(\tskid.east)$),
          \p2=($(\tskid_si\cursif.center)-(\tskid.south east)$),
          \n1={veclen(\p1)-\pgflinewidth-(\nsckf -\i)*0.35cm},
          \n2={veclen(\p2)-\pgflinewidth-(\nsckf -\i)*0.10cm},
          \n3={(\nsckf -\i)*0.175cm}
          in [bindfwd] (\tskid_si\cursif) --++ (-\n3,-\n2) --++ (-\n1,0.0) -- (\tskid_so\cursof);
      }{
        \draw let
          \p1=($(\tskid.west)-(\tskid.east)$),
          \p2=($(\tskid_si\cursif.center)-(\tskid.south west)$),
          \n1={veclen(\p1)-\pgflinewidth-(\nsckf -\i)*0.35cm},
          \n2={veclen(\p2)-\pgflinewidth-(\nsckf -\i)*0.10cm},
          \n3={(\nsckf -\i)*0.175cm}
          in [bindfwd] (\tskid_si\cursif) --++ (\n3,-\n2) --++ (\n1,0.0) -- (\tskid_so\cursof);
      }
    }
  \fi
}

% #1 node options (optional parameter)
% #2 id {ti}
% #3 position {x,y} (can be empty)
% #4 label {label_of_the_task}
% #5 number of paths (can't be 0)
% #6 a list of attributes (can be {"rev"} and can also be empty)
\newcommand{\select}[6][]{
  \ifnum \numexpr #5 > 0
    \ifthenelse{\equal{#6}{}} {
      \task [thick,densely dashdotted,#1] {#2} {#3} {#4} {#5} {1} {0} {"sckn"};
    }{
      \task [thick,densely dashdotted,#1] {#2} {#3} {#4} {#5} {1} {0} {"sckn",#6};
    }
  \fi
}

% #1 node options (optional parameter)
% #2 id {ti}
% #3 position {x,y} (can be empty)
% #4 label {label_of_the_task}
% #5 number of paths (can't be 0)
% #6 a list of attributes (can be {"rev"} and can also be empty)
\newcommand{\commute}[6][]{
  \ifnum \numexpr #5 > 0
    \ifthenelse{\equal{#6}{}} {
      \task [thick,densely dashdotted,#1] {#2} {#3} {#4} {2} {#5} {0} {"sckn"};
    }{
      \task [thick,densely dashdotted,#1] {#2} {#3} {#4} {2} {#5} {0} {"sckn",#6};
    }
  \fi
}

\long\def\@nodedefined#1#2#3{%
  \@ifundefined{pgf@sh@ns@#1}{#3}{#2}%
}

\long\def\@moduledefined#1#2#3{%
  \@ifundefined{@mdl@#1}{#3}{#2}%
}

% #1 node options (optional parameter)
% #2 list of tasks {t0, t1, t2, ...}
% #3 number of clones
\newcommand{\clone}[3][]{
  % parse arguments
  \pgfmathsetmacro{\ntsk}{dim(#2)}
  \def\nclones{#3};
  \pgfmathsetmacro{\ntskmone}{int(\ntsk - 1)}
  \foreach \i in {0,...,\ntskmone}{
    \ifthenelse{\ntskmone=0}{
      \pgfmathsetmacro{\curtsk}{#2}
    }{
      \pgfmathsetmacro{\curtsk}{{#2}[\i]}
    }
    \ifthenelse{\equal{\nclones}{}} {}
    {
      \ifnum \numexpr\nclones > 0
        \foreach \c in {1,...,\nclones}{
          \pgfmathsetmacro{\rc}{\nclones-\c}
          \pgfmathsetmacro{\clnshft}{(\rc+1)*0.075cm}

          \begin{scope}[on background layer]
            \path let
              \p1=(\curtsk),
              \p1=($(\curtsk.west)-(\curtsk.east)$),
              \p2=($(\curtsk.north)-(\curtsk.south)$),
              \n1={veclen(\p1)-\pgflinewidth},
              \n2={veclen(\p2)-\pgflinewidth},
              in node [task, taskcln, at=(\curtsk), minimum width=\n1, minimum height=\n2, inner sep=0.0cm, xshift=\clnshft, yshift=\clnshft,#1] (\curtsk_cln\c) {};
          \end{scope}

          % loop over input sockets
          \foreach \si in {1,...,100}{
            \@nodedefined{\curtsk_si\si}{
              \@nodedefined{\curtsk_si\si_fwd}{
                \def\sckstya{sfwd};
                \def\sckstyb{sfwdcln};
              }{
                \def\sckstya{sin};
                \def\sckstyb{sincln};
              }
              \begin{scope}[on background layer]
                \node[\sckstya, \sckstyb, at=(\curtsk_si\si), xshift=\clnshft, yshift=\clnshft,#1] (\curtsk_cln\c_si\si) {};
              \end{scope}
            }{
              \breakforeach
            }
          }

          % loop over output sockets
          \foreach \so in {1,...,100}{
            \@nodedefined{\curtsk_so\so}{
              \@nodedefined{\curtsk_so\so_fwd}{
                \def\sckstya{sfwd};
                \def\sckstyb{sfwdcln};
              }{
                \def\sckstya{sout};
                \def\sckstyb{soutcln};
              }
              \begin{scope}[on background layer]
                \node[\sckstya, \sckstyb, at=(\curtsk_so\so), xshift=\clnshft, yshift=\clnshft,#1] (\curtsk_cln\c_so\so) {};
              \end{scope}
            }{
              \breakforeach
            }
          }
        }
      \fi
    }
  }
}

% #1 node options (optional parameter)
% #2 list of tasks {t0, t1, t2, ...}
% #3 id {mi}
% #4 label {label_of_the_module}
\newcommand{\module}[4][]{
  % parse arguments
  \pgfmathsetmacro{\ntsk}{dim(#2)}
  \def\tids{};
  \pgfmathsetmacro{\ntskmone}{int(\ntsk - 1)}
  \foreach \i in {0,...,\ntskmone}{
    \ifthenelse{\ntskmone=0}{
      \pgfmathsetmacro{\curtsk}{#2}
    }{
      \pgfmathsetmacro{\curtsk}{{#2}[\i]}
    }
    \xdef\tids{\tids (\curtsk)}

    % loop over task clones
    \def\tclnids{};
    \foreach \cid in {1,...,100}{
      \@nodedefined{\curtsk_cln\cid}{
        \xdef\tclnids{\tclnids (\curtsk_cln\cid)}
        \def\sclnids{};
        \foreach \si in {1,...,100}{
          \@nodedefined{\curtsk_cln\cid_si\si}{
            \xdef\sclnids{\sclnids (\curtsk_cln\cid_si\si)}
          }{
            \breakforeach
          }
        }
        \foreach \so in {1,...,100}{
          \@nodedefined{\curtsk_cln\cid_so\so}{
            \xdef\sclnids{\sclnids (\curtsk_cln\cid_so\so)}
          }{
            \breakforeach
          }
        }
        \xdef\tclnids{\tclnids \sclnids}
      }{
        \breakforeach
      }
    }

    % loop over input sockets
    \def\sids{};
    \foreach \si in {1,...,100}{
      \@nodedefined{\curtsk_si\si}{
        \xdef\sids{\sids (\curtsk_si\si)}
      }{
        \breakforeach
      }
    }

    % loop over output sockets
    \foreach \so in {1,...,100}{
      \@nodedefined{\curtsk_so\so}{
        \xdef\sids{\sids (\curtsk_so\so)}
      }{
        \breakforeach
      }
    }
    \xdef\tids{\tids \sids \tclnids}
  }
  \def\mdlid{#3};
  \def\mdllabl{#4};
  \def\@mdl@#3{\tids}; % defined for the sequence optimization

  % start drawing
  \node[module, label={[Paired-3,align=center]below:\mdllabl}, fit=\tids,#1] (\mdlid) {};
}

% #1 node options (optional parameter)
% #2 list of tasks of modules {t0, m1, t2, ...}
% #3 id {si}
% #4 label {label_of_the_sequence}
% #5 number of threads (can be 0 or empty)
\newcommand{\sequence}[5][]{
  % parse arguments
  \pgfmathsetmacro{\ntsk}{dim(#2)}
  \def\ids{};
  \pgfmathsetmacro{\ntskmone}{int(\ntsk - 1)}
  \foreach \i in {0,...,\ntskmone}{
    \ifthenelse{\ntskmone=0}{
      \pgfmathsetmacro{\curobj}{#2}
    }{
      \pgfmathsetmacro{\curobj}{{#2}[\i]}
    }
    \xdef\ids{\ids (\curobj)}
    % if it is a module, then we found task and sockets before
    \@moduledefined{\curobj}{
      \xdef\ids{\ids \@mdl@\curobj}
    }{
      % loop over task clones
      \def\tclnids{};
      \foreach \cid in {1,...,100}{
        \@nodedefined{\curobj_cln\cid}{
          \xdef\tclnids{\tclnids (\curobj_cln\cid)}
          \def\sclnids{};
          \foreach \si in {1,...,100}{
            \@nodedefined{\curobj_cln\cid_si\si}{
              \xdef\sclnids{\sclnids (\curobj_cln\cid_si\si)}
            }{
              \breakforeach
            }
          }
          \foreach \so in {1,...,100}{
            \@nodedefined{\curobj_cln\cid_so\so}{
              \xdef\sclnids{\sclnids (\curobj_cln\cid_so\so)}
            }{
              \breakforeach
            }
          }
          \xdef\tclnids{\tclnids \sclnids}
        }{
          \breakforeach
        }
      }

      % loop over input sockets
      \def\sids{};
      \foreach \si in {1,...,100}{
        \@nodedefined{\curobj_si\si}{
          \xdef\sids{\sids (\curobj_si\si)}
        }{
          \breakforeach
        }
      }
      % loop over output sockets
      \foreach \so in {1,...,100}{
        \@nodedefined{\curobj_so\so}{
          \xdef\sids{\sids (\curobj_so\so)}
        }{
          \breakforeach
        }
      }
      \xdef\ids{\ids \sids \tclnids}
    }
  }
  \def\seqid{#3};
  \def\seqlabl{#4};
  \def\nthreads{#5};

  % start drawing
  \node[seq, label={[Paired-11,align=center]below:\seqlabl}, fit=\ids,#1] (\seqid) {};

  % draw the threads
  \pgfmathtruncatemacro{\xlshft}{\nthreads*0.1cm}
  \ifthenelse{\equal{\nthreads}{}} {} {
    \ifnum \numexpr\nthreads > 0
      \node[thrshdw, at=(\seqid.north), xshift=-0.075cm, minimum width=\xlshft*2+0.15cm] (\seqid_thr_shdw) {};
      \foreach \t in {1,...,\nthreads}{
        \pgfmathtruncatemacro{\tmone}{\t-1}
        \draw[thick] let
          \p1=(\seqid.north)
          in plot [smooth,tension=0.7, xshift=(\x1+\tmone*0.2cm-\xlshft), yshift=(\y1-0.25cm)] coordinates {(0,0.5) (0.075,0.4375) (-0.05,0.3125) (0.1,0.125) (0,0)} node (\seqid_thr\t){};
      }
    \fi
  }
}

% alias of previously defined sequence
\newcommand{\stage}[5][]{
  \sequence[#1]{#2}{#3}{#4}{#5}
}

\newcommand{\legend}[1][]{
  \begin{scope}[#1]
    \node[draw=Paired-1, rounded corners=0pt, minimum height=0.3cm, minimum width=0.7cm, text=Paired-1, fill=white, label={right:Parallel task}] (l1) at (+0.0, 1.9) {};
    \node[draw=Paired-1, rounded corners=0pt, minimum height=0.3cm, minimum width=0.7cm, text=Paired-1, fill=Paired-1!20, label={right:Sequential task}] (l2) at (+0.0, 1.4) {};
    \node[draw=Paired-1, rounded corners=0pt, minimum height=0.3cm, minimum width=0.7cm, text=Paired-3, fill=white, thick, densely dashdotted, label={right:Ctrl flow task}] (l3) at (+0.0, 0.9) {};
    \node[sin,  label={right:Input socket} ] (l4) at (+3.5, 1.9) {};
    \node[sout, label={right:Output socket}] (l5) at (+3.5, 1.4) {};
    \node[sfwd, label={right:Forward socket}] (l6) at (+3.5, 0.9) {};
    \node[draw=Paired-11, rounded corners=0pt, minimum height=0.3cm, minimum width=0.7cm, dashed, label={right:Sequence or pipeline stage}] (l7) at (+7.0, 1.4) {};
    \node[draw=Paired-3, rounded corners=0pt, minimum height=0.3cm, minimum width=0.7cm, text=Paired-3, dashed, label={right:Module}] (l8) at (+7.0, 1.9) {};
    \node[] (l9) at (11.15, 1.9) {};
    \draw[thick] plot [smooth,tension=0.7, xshift=7cm, yshift=0.7cm] coordinates {(0,0.375) (0.056,0.3228) (-0.0375,0.234) (0.075,0.093) (0,0)} node (l10){};
    \node[] (l11) at (8.625, 0.9) {Software thread};
    \node[draw, fit=(l1) (l2) (l3) (l4) (l5) (l6) (l7) (l8) (l9) (l11)] (legend) {};
  \end{scope}
}

\newcommand{\thread}[2][]{
  \begin{scope}[#1]
    \draw[thick] plot [smooth,tension=0.7] coordinates {(0,1) (0.15,0.875) (-0.1,0.625) (0.2,0.25) (0,0)} node (#2){};
  \end{scope}
}

\newcommand{\merge}[2][]{
  \begin{scope}[#1]
    \def\sy{2.5cm}
    \def\he{0.5cm}
    \node (P0) at (0, \sy+\he) {};
    \node (Pn) at (0, \sy-\he) {};

    \node (Q) at (1.25cm, \sy+0cm) {};
    \coordinate (Qf) at ([xshift=-0.25cm]Q.west); % we collect the edges in front of Q

    \draw[->,thick,#2] (P0) .. controls (0.75,\sy+\he) and (0.25,\sy+0cm) .. (Qf) -- (Q); % (Q) is for a better line join
    \draw[->,thick,#2] (Pn) .. controls (0.75,\sy-\he) and (0.25,\sy+0cm) .. (Qf) -- (Q); % (Q) is for a better line join
  \end{scope}
}

\newcommand{\diverge}[2][]{
  \begin{scope}[#1]
    \def\sy{2.5cm}
    \def\he{0.5cm}
    \node (P0) at (1.25, \sy+\he) {};
    \node (Pn) at (1.25, \sy-\he) {};

    \node (Q) at (0cm, \sy+0cm) {};
    \coordinate (Qf) at ([xshift=+0.25cm]Q.west); % we collect the edges in front of Q

    \draw[<-,thick,#2] (P0) .. controls (0.15cm,\sy+\he) and (1cm,\sy+0cm) .. (Qf); % (Q) is for a better line join
    \draw[<-,thick,#2] (Pn) .. controls (0.15,\sy-\he) and (1,\sy+0cm) .. (Qf); % (Q) is for a better line join
  \end{scope}
}
